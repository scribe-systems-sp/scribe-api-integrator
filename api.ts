/* tslint:disable */
/* eslint-disable */
/**
 * Integrator API
 * API for your scryba brokers
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BodyDeleteBrokerApiV1BrokersBrokerDelete
 */
export interface BodyDeleteBrokerApiV1BrokersBrokerDelete {
    /**
     * 
     * @type {number}
     * @memberof BodyDeleteBrokerApiV1BrokersBrokerDelete
     */
    broker_id: number;
}
/**
 * 
 * @export
 * @interface BodyDeleteCardApiV1CardsCardDelete
 */
export interface BodyDeleteCardApiV1CardsCardDelete {
    /**
     * 
     * @type {number}
     * @memberof BodyDeleteCardApiV1CardsCardDelete
     */
    card_id: number;
}
/**
 * 
 * @export
 * @interface BodyDeleteTimeRecordApiV1RecordsRecordDelete
 */
export interface BodyDeleteTimeRecordApiV1RecordsRecordDelete {
    /**
     * 
     * @type {number}
     * @memberof BodyDeleteTimeRecordApiV1RecordsRecordDelete
     */
    recordId: number;
}
/**
 * 
 * @export
 * @interface BodySetActiveApiV1CardsSetActivePatch
 */
export interface BodySetActiveApiV1CardsSetActivePatch {
    /**
     * 
     * @type {boolean}
     * @memberof BodySetActiveApiV1CardsSetActivePatch
     */
    active: boolean;
    /**
     * 
     * @type {number}
     * @memberof BodySetActiveApiV1CardsSetActivePatch
     */
    card_id: number;
}
/**
 * 
 * @export
 * @interface BodySetBrokerConfigApiV1ConfigBrokerPut
 */
export interface BodySetBrokerConfigApiV1ConfigBrokerPut {
    /**
     * 
     * @type {string}
     * @memberof BodySetBrokerConfigApiV1ConfigBrokerPut
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof BodySetBrokerConfigApiV1ConfigBrokerPut
     */
    data_format?: string;
    /**
     * 
     * @type {string}
     * @memberof BodySetBrokerConfigApiV1ConfigBrokerPut
     */
    broker_name: string;
}
/**
 * 
 * @export
 * @interface Broker
 */
export interface Broker {
    /**
     * 
     * @type {string}
     * @memberof Broker
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Broker
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Brokers
 */
export interface Brokers {
    /**
     * 
     * @type {Array<Array<any>>}
     * @memberof Brokers
     */
    brokers: Array<Array<any>>;
}
/**
 * 
 * @export
 * @interface CardsData
 */
export interface CardsData {
    /**
     * 
     * @type {Array<Array<any>>}
     * @memberof CardsData
     */
    cards: Array<Array<any>>;
}
/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    data_format?: string;
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    data: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface NewCard
 */
export interface NewCard {
    /**
     * 
     * @type {number}
     * @memberof NewCard
     */
    userId: number;
    /**
     * 
     * @type {string}
     * @memberof NewCard
     */
    secret: string;
}
/**
 * 
 * @export
 * @interface RecordsCount
 */
export interface RecordsCount {
    /**
     * 
     * @type {number}
     * @memberof RecordsCount
     */
    count: number;
}
/**
 * 
 * @export
 * @interface TimeRecordFromBroker
 */
export interface TimeRecordFromBroker {
    /**
     * 
     * @type {string}
     * @memberof TimeRecordFromBroker
     */
    broker_name?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeRecordFromBroker
     */
    cardSecret: string;
    /**
     * 
     * @type {string}
     * @memberof TimeRecordFromBroker
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeRecordFromBroker
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * BrokersApi - axios parameter creator
 * @export
 */
export const BrokersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new broker with specified parametres.
         * @summary Create Broker
         * @param {Broker} broker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersCreateBroker: async (broker: Broker, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'broker' is not null or undefined
            if (broker === null || broker === undefined) {
                throw new RequiredError('broker','Required parameter broker was null or undefined when calling apiV1BrokersCreateBroker.');
            }
            const localVarPath = `/integrator/api/v1/brokers/broker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof broker !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(broker !== undefined ? broker : {}) : (broker || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes broker. Note, that if the broker will be deleted, all the dependent timerecords for this broker will be also deleted cascadely.
         * @summary Delete Broker
         * @param {BodyDeleteBrokerApiV1BrokersBrokerDelete} bodyDeleteBrokerApiV1BrokersBrokerDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersDeleteBroker: async (bodyDeleteBrokerApiV1BrokersBrokerDelete: BodyDeleteBrokerApiV1BrokersBrokerDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeleteBrokerApiV1BrokersBrokerDelete' is not null or undefined
            if (bodyDeleteBrokerApiV1BrokersBrokerDelete === null || bodyDeleteBrokerApiV1BrokersBrokerDelete === undefined) {
                throw new RequiredError('bodyDeleteBrokerApiV1BrokersBrokerDelete','Required parameter bodyDeleteBrokerApiV1BrokersBrokerDelete was null or undefined when calling apiV1BrokersDeleteBroker.');
            }
            const localVarPath = `/integrator/api/v1/brokers/broker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeleteBrokerApiV1BrokersBrokerDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeleteBrokerApiV1BrokersBrokerDelete !== undefined ? bodyDeleteBrokerApiV1BrokersBrokerDelete : {}) : (bodyDeleteBrokerApiV1BrokersBrokerDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all brokers using provided filter parametres
         * @summary Get All Brokers
         * @param {number} [brokerId] Get only broker with specified id.
         * @param {string} [name] Return broker only with specified name.
         * @param {string} [nameSubstring] Return broker which has specified substring in his name.
         * @param {Array<string>} [values] Returns only specified parametres.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersGetAllBrokers: async (brokerId?: number, name?: string, nameSubstring?: string, values?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/brokers/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (brokerId !== undefined) {
                localVarQueryParameter['broker_id'] = brokerId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameSubstring !== undefined) {
                localVarQueryParameter['name_substring'] = nameSubstring;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrokersApi - functional programming interface
 * @export
 */
export const BrokersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new broker with specified parametres.
         * @summary Create Broker
         * @param {Broker} broker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BrokersCreateBroker(broker: Broker, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await BrokersApiAxiosParamCreator(configuration).apiV1BrokersCreateBroker(broker, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes broker. Note, that if the broker will be deleted, all the dependent timerecords for this broker will be also deleted cascadely.
         * @summary Delete Broker
         * @param {BodyDeleteBrokerApiV1BrokersBrokerDelete} bodyDeleteBrokerApiV1BrokersBrokerDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete: BodyDeleteBrokerApiV1BrokersBrokerDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await BrokersApiAxiosParamCreator(configuration).apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all brokers using provided filter parametres
         * @summary Get All Brokers
         * @param {number} [brokerId] Get only broker with specified id.
         * @param {string} [name] Return broker only with specified name.
         * @param {string} [nameSubstring] Return broker which has specified substring in his name.
         * @param {Array<string>} [values] Returns only specified parametres.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BrokersGetAllBrokers(brokerId?: number, name?: string, nameSubstring?: string, values?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brokers>> {
            const localVarAxiosArgs = await BrokersApiAxiosParamCreator(configuration).apiV1BrokersGetAllBrokers(brokerId, name, nameSubstring, values, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BrokersApi - factory interface
 * @export
 */
export const BrokersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates new broker with specified parametres.
         * @summary Create Broker
         * @param {Broker} broker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersCreateBroker(broker: Broker, options?: any): AxiosPromise<any> {
            return BrokersApiFp(configuration).apiV1BrokersCreateBroker(broker, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes broker. Note, that if the broker will be deleted, all the dependent timerecords for this broker will be also deleted cascadely.
         * @summary Delete Broker
         * @param {BodyDeleteBrokerApiV1BrokersBrokerDelete} bodyDeleteBrokerApiV1BrokersBrokerDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete: BodyDeleteBrokerApiV1BrokersBrokerDelete, options?: any): AxiosPromise<any> {
            return BrokersApiFp(configuration).apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all brokers using provided filter parametres
         * @summary Get All Brokers
         * @param {number} [brokerId] Get only broker with specified id.
         * @param {string} [name] Return broker only with specified name.
         * @param {string} [nameSubstring] Return broker which has specified substring in his name.
         * @param {Array<string>} [values] Returns only specified parametres.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersGetAllBrokers(brokerId?: number, name?: string, nameSubstring?: string, values?: Array<string>, options?: any): AxiosPromise<Brokers> {
            return BrokersApiFp(configuration).apiV1BrokersGetAllBrokers(brokerId, name, nameSubstring, values, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1BrokersCreateBroker operation in BrokersApi.
 * @export
 * @interface BrokersApiApiV1BrokersCreateBrokerRequest
 */
export interface BrokersApiApiV1BrokersCreateBrokerRequest {
    /**
     * 
     * @type {Broker}
     * @memberof BrokersApiApiV1BrokersCreateBroker
     */
    readonly broker: Broker
}

/**
 * Request parameters for apiV1BrokersDeleteBroker operation in BrokersApi.
 * @export
 * @interface BrokersApiApiV1BrokersDeleteBrokerRequest
 */
export interface BrokersApiApiV1BrokersDeleteBrokerRequest {
    /**
     * 
     * @type {BodyDeleteBrokerApiV1BrokersBrokerDelete}
     * @memberof BrokersApiApiV1BrokersDeleteBroker
     */
    readonly bodyDeleteBrokerApiV1BrokersBrokerDelete: BodyDeleteBrokerApiV1BrokersBrokerDelete
}

/**
 * Request parameters for apiV1BrokersGetAllBrokers operation in BrokersApi.
 * @export
 * @interface BrokersApiApiV1BrokersGetAllBrokersRequest
 */
export interface BrokersApiApiV1BrokersGetAllBrokersRequest {
    /**
     * Get only broker with specified id.
     * @type {number}
     * @memberof BrokersApiApiV1BrokersGetAllBrokers
     */
    readonly brokerId?: number

    /**
     * Return broker only with specified name.
     * @type {string}
     * @memberof BrokersApiApiV1BrokersGetAllBrokers
     */
    readonly name?: string

    /**
     * Return broker which has specified substring in his name.
     * @type {string}
     * @memberof BrokersApiApiV1BrokersGetAllBrokers
     */
    readonly nameSubstring?: string

    /**
     * Returns only specified parametres.
     * @type {Array<string>}
     * @memberof BrokersApiApiV1BrokersGetAllBrokers
     */
    readonly values?: Array<string>
}

/**
 * BrokersApi - object-oriented interface
 * @export
 * @class BrokersApi
 * @extends {BaseAPI}
 */
export class BrokersApi extends BaseAPI {
    /**
     * Creates new broker with specified parametres.
     * @summary Create Broker
     * @param {BrokersApiApiV1BrokersCreateBrokerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public apiV1BrokersCreateBroker(requestParameters: BrokersApiApiV1BrokersCreateBrokerRequest, options?: any) {
        return BrokersApiFp(this.configuration).apiV1BrokersCreateBroker(requestParameters.broker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes broker. Note, that if the broker will be deleted, all the dependent timerecords for this broker will be also deleted cascadely.
     * @summary Delete Broker
     * @param {BrokersApiApiV1BrokersDeleteBrokerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public apiV1BrokersDeleteBroker(requestParameters: BrokersApiApiV1BrokersDeleteBrokerRequest, options?: any) {
        return BrokersApiFp(this.configuration).apiV1BrokersDeleteBroker(requestParameters.bodyDeleteBrokerApiV1BrokersBrokerDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all brokers using provided filter parametres
     * @summary Get All Brokers
     * @param {BrokersApiApiV1BrokersGetAllBrokersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public apiV1BrokersGetAllBrokers(requestParameters: BrokersApiApiV1BrokersGetAllBrokersRequest = {}, options?: any) {
        return BrokersApiFp(this.configuration).apiV1BrokersGetAllBrokers(requestParameters.brokerId, requestParameters.name, requestParameters.nameSubstring, requestParameters.values, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CardsApi - axios parameter creator
 * @export
 */
export const CardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new card
         * @summary Create Card
         * @param {NewCard} newCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsCreateCard: async (newCard: NewCard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCard' is not null or undefined
            if (newCard === null || newCard === undefined) {
                throw new RequiredError('newCard','Required parameter newCard was null or undefined when calling apiV1CardsCreateCard.');
            }
            const localVarPath = `/integrator/api/v1/cards/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof newCard !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(newCard !== undefined ? newCard : {}) : (newCard || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deleets card. Note, that if the card will be deleted, all the dependent timerecords for this card will be also deleted cascadely.
         * @summary Delete Card
         * @param {BodyDeleteCardApiV1CardsCardDelete} bodyDeleteCardApiV1CardsCardDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsDeleteCard: async (bodyDeleteCardApiV1CardsCardDelete: BodyDeleteCardApiV1CardsCardDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeleteCardApiV1CardsCardDelete' is not null or undefined
            if (bodyDeleteCardApiV1CardsCardDelete === null || bodyDeleteCardApiV1CardsCardDelete === undefined) {
                throw new RequiredError('bodyDeleteCardApiV1CardsCardDelete','Required parameter bodyDeleteCardApiV1CardsCardDelete was null or undefined when calling apiV1CardsDeleteCard.');
            }
            const localVarPath = `/integrator/api/v1/cards/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeleteCardApiV1CardsCardDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeleteCardApiV1CardsCardDelete !== undefined ? bodyDeleteCardApiV1CardsCardDelete : {}) : (bodyDeleteCardApiV1CardsCardDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for and returns card using specified filter parametres.
         * @summary Filter And Get
         * @param {number} [id] Get only card with specified id.
         * @param {number} [userId] Return cards only for specified userIds.
         * @param {boolean} [active] Return cards which has provided status.
         * @param {string} [secret] Return card with specified secret.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsFilterAndGet: async (id?: number, userId?: number, active?: boolean, secret?: string, values?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/cards/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or deactivates card. Deactivated cards are not permitted to do any actions.
         * @summary Set Active
         * @param {BodySetActiveApiV1CardsSetActivePatch} bodySetActiveApiV1CardsSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsSetActive: async (bodySetActiveApiV1CardsSetActivePatch: BodySetActiveApiV1CardsSetActivePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodySetActiveApiV1CardsSetActivePatch' is not null or undefined
            if (bodySetActiveApiV1CardsSetActivePatch === null || bodySetActiveApiV1CardsSetActivePatch === undefined) {
                throw new RequiredError('bodySetActiveApiV1CardsSetActivePatch','Required parameter bodySetActiveApiV1CardsSetActivePatch was null or undefined when calling apiV1CardsSetActive.');
            }
            const localVarPath = `/integrator/api/v1/cards/setActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodySetActiveApiV1CardsSetActivePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodySetActiveApiV1CardsSetActivePatch !== undefined ? bodySetActiveApiV1CardsSetActivePatch : {}) : (bodySetActiveApiV1CardsSetActivePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardsApi - functional programming interface
 * @export
 */
export const CardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new card
         * @summary Create Card
         * @param {NewCard} newCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CardsCreateCard(newCard: NewCard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await CardsApiAxiosParamCreator(configuration).apiV1CardsCreateCard(newCard, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deleets card. Note, that if the card will be deleted, all the dependent timerecords for this card will be also deleted cascadely.
         * @summary Delete Card
         * @param {BodyDeleteCardApiV1CardsCardDelete} bodyDeleteCardApiV1CardsCardDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete: BodyDeleteCardApiV1CardsCardDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await CardsApiAxiosParamCreator(configuration).apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Searches for and returns card using specified filter parametres.
         * @summary Filter And Get
         * @param {number} [id] Get only card with specified id.
         * @param {number} [userId] Return cards only for specified userIds.
         * @param {boolean} [active] Return cards which has provided status.
         * @param {string} [secret] Return card with specified secret.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CardsFilterAndGet(id?: number, userId?: number, active?: boolean, secret?: string, values?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardsData>> {
            const localVarAxiosArgs = await CardsApiAxiosParamCreator(configuration).apiV1CardsFilterAndGet(id, userId, active, secret, values, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or deactivates card. Deactivated cards are not permitted to do any actions.
         * @summary Set Active
         * @param {BodySetActiveApiV1CardsSetActivePatch} bodySetActiveApiV1CardsSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch: BodySetActiveApiV1CardsSetActivePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await CardsApiAxiosParamCreator(configuration).apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CardsApi - factory interface
 * @export
 */
export const CardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates new card
         * @summary Create Card
         * @param {NewCard} newCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsCreateCard(newCard: NewCard, options?: any): AxiosPromise<any> {
            return CardsApiFp(configuration).apiV1CardsCreateCard(newCard, options).then((request) => request(axios, basePath));
        },
        /**
         * Deleets card. Note, that if the card will be deleted, all the dependent timerecords for this card will be also deleted cascadely.
         * @summary Delete Card
         * @param {BodyDeleteCardApiV1CardsCardDelete} bodyDeleteCardApiV1CardsCardDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete: BodyDeleteCardApiV1CardsCardDelete, options?: any): AxiosPromise<any> {
            return CardsApiFp(configuration).apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for and returns card using specified filter parametres.
         * @summary Filter And Get
         * @param {number} [id] Get only card with specified id.
         * @param {number} [userId] Return cards only for specified userIds.
         * @param {boolean} [active] Return cards which has provided status.
         * @param {string} [secret] Return card with specified secret.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsFilterAndGet(id?: number, userId?: number, active?: boolean, secret?: string, values?: Array<string>, options?: any): AxiosPromise<CardsData> {
            return CardsApiFp(configuration).apiV1CardsFilterAndGet(id, userId, active, secret, values, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or deactivates card. Deactivated cards are not permitted to do any actions.
         * @summary Set Active
         * @param {BodySetActiveApiV1CardsSetActivePatch} bodySetActiveApiV1CardsSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch: BodySetActiveApiV1CardsSetActivePatch, options?: any): AxiosPromise<any> {
            return CardsApiFp(configuration).apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1CardsCreateCard operation in CardsApi.
 * @export
 * @interface CardsApiApiV1CardsCreateCardRequest
 */
export interface CardsApiApiV1CardsCreateCardRequest {
    /**
     * 
     * @type {NewCard}
     * @memberof CardsApiApiV1CardsCreateCard
     */
    readonly newCard: NewCard
}

/**
 * Request parameters for apiV1CardsDeleteCard operation in CardsApi.
 * @export
 * @interface CardsApiApiV1CardsDeleteCardRequest
 */
export interface CardsApiApiV1CardsDeleteCardRequest {
    /**
     * 
     * @type {BodyDeleteCardApiV1CardsCardDelete}
     * @memberof CardsApiApiV1CardsDeleteCard
     */
    readonly bodyDeleteCardApiV1CardsCardDelete: BodyDeleteCardApiV1CardsCardDelete
}

/**
 * Request parameters for apiV1CardsFilterAndGet operation in CardsApi.
 * @export
 * @interface CardsApiApiV1CardsFilterAndGetRequest
 */
export interface CardsApiApiV1CardsFilterAndGetRequest {
    /**
     * Get only card with specified id.
     * @type {number}
     * @memberof CardsApiApiV1CardsFilterAndGet
     */
    readonly id?: number

    /**
     * Return cards only for specified userIds.
     * @type {number}
     * @memberof CardsApiApiV1CardsFilterAndGet
     */
    readonly userId?: number

    /**
     * Return cards which has provided status.
     * @type {boolean}
     * @memberof CardsApiApiV1CardsFilterAndGet
     */
    readonly active?: boolean

    /**
     * Return card with specified secret.
     * @type {string}
     * @memberof CardsApiApiV1CardsFilterAndGet
     */
    readonly secret?: string

    /**
     * Only return specified fields.
     * @type {Array<string>}
     * @memberof CardsApiApiV1CardsFilterAndGet
     */
    readonly values?: Array<string>
}

/**
 * Request parameters for apiV1CardsSetActive operation in CardsApi.
 * @export
 * @interface CardsApiApiV1CardsSetActiveRequest
 */
export interface CardsApiApiV1CardsSetActiveRequest {
    /**
     * 
     * @type {BodySetActiveApiV1CardsSetActivePatch}
     * @memberof CardsApiApiV1CardsSetActive
     */
    readonly bodySetActiveApiV1CardsSetActivePatch: BodySetActiveApiV1CardsSetActivePatch
}

/**
 * CardsApi - object-oriented interface
 * @export
 * @class CardsApi
 * @extends {BaseAPI}
 */
export class CardsApi extends BaseAPI {
    /**
     * Creates new card
     * @summary Create Card
     * @param {CardsApiApiV1CardsCreateCardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public apiV1CardsCreateCard(requestParameters: CardsApiApiV1CardsCreateCardRequest, options?: any) {
        return CardsApiFp(this.configuration).apiV1CardsCreateCard(requestParameters.newCard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deleets card. Note, that if the card will be deleted, all the dependent timerecords for this card will be also deleted cascadely.
     * @summary Delete Card
     * @param {CardsApiApiV1CardsDeleteCardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public apiV1CardsDeleteCard(requestParameters: CardsApiApiV1CardsDeleteCardRequest, options?: any) {
        return CardsApiFp(this.configuration).apiV1CardsDeleteCard(requestParameters.bodyDeleteCardApiV1CardsCardDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for and returns card using specified filter parametres.
     * @summary Filter And Get
     * @param {CardsApiApiV1CardsFilterAndGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public apiV1CardsFilterAndGet(requestParameters: CardsApiApiV1CardsFilterAndGetRequest = {}, options?: any) {
        return CardsApiFp(this.configuration).apiV1CardsFilterAndGet(requestParameters.id, requestParameters.userId, requestParameters.active, requestParameters.secret, requestParameters.values, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or deactivates card. Deactivated cards are not permitted to do any actions.
     * @summary Set Active
     * @param {CardsApiApiV1CardsSetActiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public apiV1CardsSetActive(requestParameters: CardsApiApiV1CardsSetActiveRequest, options?: any) {
        return CardsApiFp(this.configuration).apiV1CardsSetActive(requestParameters.bodySetActiveApiV1CardsSetActivePatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns configuration of the broker. If provided timestamp is same returns only 304 status code.
         * @summary Get Broker Config
         * @param {string} timestamp 
         * @param {string} brokerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConfigGetBrokerConfig: async (timestamp: string, brokerName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling apiV1ConfigGetBrokerConfig.');
            }
            // verify required parameter 'brokerName' is not null or undefined
            if (brokerName === null || brokerName === undefined) {
                throw new RequiredError('brokerName','Required parameter brokerName was null or undefined when calling apiV1ConfigGetBrokerConfig.');
            }
            const localVarPath = `/integrator/api/v1/config/broker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = (timestamp as any instanceof Date) ?
                    (timestamp as any).toISOString() :
                    timestamp;
            }

            if (brokerName !== undefined) {
                localVarQueryParameter['broker_name'] = brokerName;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates configuration for specific broker.
         * @summary Set Broker Config
         * @param {BodySetBrokerConfigApiV1ConfigBrokerPut} bodySetBrokerConfigApiV1ConfigBrokerPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConfigSetBrokerConfig: async (bodySetBrokerConfigApiV1ConfigBrokerPut: BodySetBrokerConfigApiV1ConfigBrokerPut, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodySetBrokerConfigApiV1ConfigBrokerPut' is not null or undefined
            if (bodySetBrokerConfigApiV1ConfigBrokerPut === null || bodySetBrokerConfigApiV1ConfigBrokerPut === undefined) {
                throw new RequiredError('bodySetBrokerConfigApiV1ConfigBrokerPut','Required parameter bodySetBrokerConfigApiV1ConfigBrokerPut was null or undefined when calling apiV1ConfigSetBrokerConfig.');
            }
            const localVarPath = `/integrator/api/v1/config/broker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodySetBrokerConfigApiV1ConfigBrokerPut !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodySetBrokerConfigApiV1ConfigBrokerPut !== undefined ? bodySetBrokerConfigApiV1ConfigBrokerPut : {}) : (bodySetBrokerConfigApiV1ConfigBrokerPut || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns configuration of the broker. If provided timestamp is same returns only 304 status code.
         * @summary Get Broker Config
         * @param {string} timestamp 
         * @param {string} brokerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConfigGetBrokerConfig(timestamp: string, brokerName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
            const localVarAxiosArgs = await ConfigApiAxiosParamCreator(configuration).apiV1ConfigGetBrokerConfig(timestamp, brokerName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates configuration for specific broker.
         * @summary Set Broker Config
         * @param {BodySetBrokerConfigApiV1ConfigBrokerPut} bodySetBrokerConfigApiV1ConfigBrokerPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut: BodySetBrokerConfigApiV1ConfigBrokerPut, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ConfigApiAxiosParamCreator(configuration).apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns configuration of the broker. If provided timestamp is same returns only 304 status code.
         * @summary Get Broker Config
         * @param {string} timestamp 
         * @param {string} brokerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConfigGetBrokerConfig(timestamp: string, brokerName: string, options?: any): AxiosPromise<Config> {
            return ConfigApiFp(configuration).apiV1ConfigGetBrokerConfig(timestamp, brokerName, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates configuration for specific broker.
         * @summary Set Broker Config
         * @param {BodySetBrokerConfigApiV1ConfigBrokerPut} bodySetBrokerConfigApiV1ConfigBrokerPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut: BodySetBrokerConfigApiV1ConfigBrokerPut, options?: any): AxiosPromise<any> {
            return ConfigApiFp(configuration).apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1ConfigGetBrokerConfig operation in ConfigApi.
 * @export
 * @interface ConfigApiApiV1ConfigGetBrokerConfigRequest
 */
export interface ConfigApiApiV1ConfigGetBrokerConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigApiApiV1ConfigGetBrokerConfig
     */
    readonly timestamp: string

    /**
     * 
     * @type {string}
     * @memberof ConfigApiApiV1ConfigGetBrokerConfig
     */
    readonly brokerName: string
}

/**
 * Request parameters for apiV1ConfigSetBrokerConfig operation in ConfigApi.
 * @export
 * @interface ConfigApiApiV1ConfigSetBrokerConfigRequest
 */
export interface ConfigApiApiV1ConfigSetBrokerConfigRequest {
    /**
     * 
     * @type {BodySetBrokerConfigApiV1ConfigBrokerPut}
     * @memberof ConfigApiApiV1ConfigSetBrokerConfig
     */
    readonly bodySetBrokerConfigApiV1ConfigBrokerPut: BodySetBrokerConfigApiV1ConfigBrokerPut
}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * Returns configuration of the broker. If provided timestamp is same returns only 304 status code.
     * @summary Get Broker Config
     * @param {ConfigApiApiV1ConfigGetBrokerConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public apiV1ConfigGetBrokerConfig(requestParameters: ConfigApiApiV1ConfigGetBrokerConfigRequest, options?: any) {
        return ConfigApiFp(this.configuration).apiV1ConfigGetBrokerConfig(requestParameters.timestamp, requestParameters.brokerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates configuration for specific broker.
     * @summary Set Broker Config
     * @param {ConfigApiApiV1ConfigSetBrokerConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public apiV1ConfigSetBrokerConfig(requestParameters: ConfigApiApiV1ConfigSetBrokerConfigRequest, options?: any) {
        return ConfigApiFp(this.configuration).apiV1ConfigSetBrokerConfig(requestParameters.bodySetBrokerConfigApiV1ConfigBrokerPut, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecordsApi - axios parameter creator
 * @export
 */
export const RecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Groups records by userId and counts them
         * @summary Count By User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsCountByUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/records/countByUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates time record. Uses card secret to identify card. If card is not active, operation will fail.
         * @summary Create Time Record
         * @param {TimeRecordFromBroker} timeRecordFromBroker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsCreateTimeRecord: async (timeRecordFromBroker: TimeRecordFromBroker, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeRecordFromBroker' is not null or undefined
            if (timeRecordFromBroker === null || timeRecordFromBroker === undefined) {
                throw new RequiredError('timeRecordFromBroker','Required parameter timeRecordFromBroker was null or undefined when calling apiV1RecordsCreateTimeRecord.');
            }
            const localVarPath = `/integrator/api/v1/records/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof timeRecordFromBroker !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(timeRecordFromBroker !== undefined ? timeRecordFromBroker : {}) : (timeRecordFromBroker || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes time record.
         * @summary Delete Time Record
         * @param {BodyDeleteTimeRecordApiV1RecordsRecordDelete} bodyDeleteTimeRecordApiV1RecordsRecordDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsDeleteTimeRecord: async (bodyDeleteTimeRecordApiV1RecordsRecordDelete: BodyDeleteTimeRecordApiV1RecordsRecordDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeleteTimeRecordApiV1RecordsRecordDelete' is not null or undefined
            if (bodyDeleteTimeRecordApiV1RecordsRecordDelete === null || bodyDeleteTimeRecordApiV1RecordsRecordDelete === undefined) {
                throw new RequiredError('bodyDeleteTimeRecordApiV1RecordsRecordDelete','Required parameter bodyDeleteTimeRecordApiV1RecordsRecordDelete was null or undefined when calling apiV1RecordsDeleteTimeRecord.');
            }
            const localVarPath = `/integrator/api/v1/records/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeleteTimeRecordApiV1RecordsRecordDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeleteTimeRecordApiV1RecordsRecordDelete !== undefined ? bodyDeleteTimeRecordApiV1RecordsRecordDelete : {}) : (bodyDeleteTimeRecordApiV1RecordsRecordDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts recourds using specified filter. Returns records count instead of their values.
         * @summary Filter And Count
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsFilterAndCount: async (recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/records/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (recordId !== undefined) {
                localVarQueryParameter['recordId'] = recordId;
            }

            if (brokerId !== undefined) {
                localVarQueryParameter['brokerId'] = brokerId;
            }

            if (cardId !== undefined) {
                localVarQueryParameter['cardId'] = cardId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (minTime !== undefined) {
                localVarQueryParameter['minTime'] = (minTime as any instanceof Date) ?
                    (minTime as any).toISOString() :
                    minTime;
            }

            if (maxTime !== undefined) {
                localVarQueryParameter['maxTime'] = (maxTime as any instanceof Date) ?
                    (maxTime as any).toISOString() :
                    maxTime;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for records using specified filter. Returns list of lists with values (and their order) that was specified by filter options
         * @summary Filter And Get
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsFilterAndGet: async (recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/records/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (recordId !== undefined) {
                localVarQueryParameter['recordId'] = recordId;
            }

            if (brokerId !== undefined) {
                localVarQueryParameter['brokerId'] = brokerId;
            }

            if (cardId !== undefined) {
                localVarQueryParameter['cardId'] = cardId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (minTime !== undefined) {
                localVarQueryParameter['minTime'] = (minTime as any instanceof Date) ?
                    (minTime as any).toISOString() :
                    minTime;
            }

            if (maxTime !== undefined) {
                localVarQueryParameter['maxTime'] = (maxTime as any instanceof Date) ?
                    (maxTime as any).toISOString() :
                    maxTime;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordsApi - functional programming interface
 * @export
 */
export const RecordsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Groups records by userId and counts them
         * @summary Count By User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsCountByUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsCountByUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates time record. Uses card secret to identify card. If card is not active, operation will fail.
         * @summary Create Time Record
         * @param {TimeRecordFromBroker} timeRecordFromBroker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsCreateTimeRecord(timeRecordFromBroker: TimeRecordFromBroker, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsCreateTimeRecord(timeRecordFromBroker, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes time record.
         * @summary Delete Time Record
         * @param {BodyDeleteTimeRecordApiV1RecordsRecordDelete} bodyDeleteTimeRecordApiV1RecordsRecordDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete: BodyDeleteTimeRecordApiV1RecordsRecordDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Counts recourds using specified filter. Returns records count instead of their values.
         * @summary Filter And Count
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsFilterAndCount(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordsCount>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsFilterAndCount(recordId, brokerId, cardId, userId, minTime, maxTime, values, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Searches for records using specified filter. Returns list of lists with values (and their order) that was specified by filter options
         * @summary Filter And Get
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsFilterAndGet(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsFilterAndGet(recordId, brokerId, cardId, userId, minTime, maxTime, values, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RecordsApi - factory interface
 * @export
 */
export const RecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Groups records by userId and counts them
         * @summary Count By User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsCountByUser(options?: any): AxiosPromise<any> {
            return RecordsApiFp(configuration).apiV1RecordsCountByUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates time record. Uses card secret to identify card. If card is not active, operation will fail.
         * @summary Create Time Record
         * @param {TimeRecordFromBroker} timeRecordFromBroker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsCreateTimeRecord(timeRecordFromBroker: TimeRecordFromBroker, options?: any): AxiosPromise<any> {
            return RecordsApiFp(configuration).apiV1RecordsCreateTimeRecord(timeRecordFromBroker, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes time record.
         * @summary Delete Time Record
         * @param {BodyDeleteTimeRecordApiV1RecordsRecordDelete} bodyDeleteTimeRecordApiV1RecordsRecordDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete: BodyDeleteTimeRecordApiV1RecordsRecordDelete, options?: any): AxiosPromise<any> {
            return RecordsApiFp(configuration).apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts recourds using specified filter. Returns records count instead of their values.
         * @summary Filter And Count
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsFilterAndCount(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, options?: any): AxiosPromise<RecordsCount> {
            return RecordsApiFp(configuration).apiV1RecordsFilterAndCount(recordId, brokerId, cardId, userId, minTime, maxTime, values, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for records using specified filter. Returns list of lists with values (and their order) that was specified by filter options
         * @summary Filter And Get
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsFilterAndGet(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, options?: any): AxiosPromise<any> {
            return RecordsApiFp(configuration).apiV1RecordsFilterAndGet(recordId, brokerId, cardId, userId, minTime, maxTime, values, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1RecordsCreateTimeRecord operation in RecordsApi.
 * @export
 * @interface RecordsApiApiV1RecordsCreateTimeRecordRequest
 */
export interface RecordsApiApiV1RecordsCreateTimeRecordRequest {
    /**
     * 
     * @type {TimeRecordFromBroker}
     * @memberof RecordsApiApiV1RecordsCreateTimeRecord
     */
    readonly timeRecordFromBroker: TimeRecordFromBroker
}

/**
 * Request parameters for apiV1RecordsDeleteTimeRecord operation in RecordsApi.
 * @export
 * @interface RecordsApiApiV1RecordsDeleteTimeRecordRequest
 */
export interface RecordsApiApiV1RecordsDeleteTimeRecordRequest {
    /**
     * 
     * @type {BodyDeleteTimeRecordApiV1RecordsRecordDelete}
     * @memberof RecordsApiApiV1RecordsDeleteTimeRecord
     */
    readonly bodyDeleteTimeRecordApiV1RecordsRecordDelete: BodyDeleteTimeRecordApiV1RecordsRecordDelete
}

/**
 * Request parameters for apiV1RecordsFilterAndCount operation in RecordsApi.
 * @export
 * @interface RecordsApiApiV1RecordsFilterAndCountRequest
 */
export interface RecordsApiApiV1RecordsFilterAndCountRequest {
    /**
     * Match specific record id. If assigned, other filters doesnt make sens.
     * @type {number}
     * @memberof RecordsApiApiV1RecordsFilterAndCount
     */
    readonly recordId?: number

    /**
     * Match specific broker id. Response will contain records only for specified broker.
     * @type {number}
     * @memberof RecordsApiApiV1RecordsFilterAndCount
     */
    readonly brokerId?: number

    /**
     * Match specific card id. Response will contain records only for specified card.
     * @type {number}
     * @memberof RecordsApiApiV1RecordsFilterAndCount
     */
    readonly cardId?: number

    /**
     * Match specific user. Response will contain only records for specified user.
     * @type {number}
     * @memberof RecordsApiApiV1RecordsFilterAndCount
     */
    readonly userId?: number

    /**
     * Minimal timestamp to search for. Response will contain records that was added after specified time.
     * @type {string}
     * @memberof RecordsApiApiV1RecordsFilterAndCount
     */
    readonly minTime?: string

    /**
     * Maximum timestamp to search for. Response will contain records that was added before specified time.
     * @type {string}
     * @memberof RecordsApiApiV1RecordsFilterAndCount
     */
    readonly maxTime?: string

    /**
     * Response records will contain only specified data.
     * @type {Array<string>}
     * @memberof RecordsApiApiV1RecordsFilterAndCount
     */
    readonly values?: Array<string>
}

/**
 * Request parameters for apiV1RecordsFilterAndGet operation in RecordsApi.
 * @export
 * @interface RecordsApiApiV1RecordsFilterAndGetRequest
 */
export interface RecordsApiApiV1RecordsFilterAndGetRequest {
    /**
     * Match specific record id. If assigned, other filters doesnt make sens.
     * @type {number}
     * @memberof RecordsApiApiV1RecordsFilterAndGet
     */
    readonly recordId?: number

    /**
     * Match specific broker id. Response will contain records only for specified broker.
     * @type {number}
     * @memberof RecordsApiApiV1RecordsFilterAndGet
     */
    readonly brokerId?: number

    /**
     * Match specific card id. Response will contain records only for specified card.
     * @type {number}
     * @memberof RecordsApiApiV1RecordsFilterAndGet
     */
    readonly cardId?: number

    /**
     * Match specific user. Response will contain only records for specified user.
     * @type {number}
     * @memberof RecordsApiApiV1RecordsFilterAndGet
     */
    readonly userId?: number

    /**
     * Minimal timestamp to search for. Response will contain records that was added after specified time.
     * @type {string}
     * @memberof RecordsApiApiV1RecordsFilterAndGet
     */
    readonly minTime?: string

    /**
     * Maximum timestamp to search for. Response will contain records that was added before specified time.
     * @type {string}
     * @memberof RecordsApiApiV1RecordsFilterAndGet
     */
    readonly maxTime?: string

    /**
     * Response records will contain only specified data.
     * @type {Array<string>}
     * @memberof RecordsApiApiV1RecordsFilterAndGet
     */
    readonly values?: Array<string>
}

/**
 * RecordsApi - object-oriented interface
 * @export
 * @class RecordsApi
 * @extends {BaseAPI}
 */
export class RecordsApi extends BaseAPI {
    /**
     * Groups records by userId and counts them
     * @summary Count By User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsCountByUser(options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsCountByUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates time record. Uses card secret to identify card. If card is not active, operation will fail.
     * @summary Create Time Record
     * @param {RecordsApiApiV1RecordsCreateTimeRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsCreateTimeRecord(requestParameters: RecordsApiApiV1RecordsCreateTimeRecordRequest, options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsCreateTimeRecord(requestParameters.timeRecordFromBroker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes time record.
     * @summary Delete Time Record
     * @param {RecordsApiApiV1RecordsDeleteTimeRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsDeleteTimeRecord(requestParameters: RecordsApiApiV1RecordsDeleteTimeRecordRequest, options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsDeleteTimeRecord(requestParameters.bodyDeleteTimeRecordApiV1RecordsRecordDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts recourds using specified filter. Returns records count instead of their values.
     * @summary Filter And Count
     * @param {RecordsApiApiV1RecordsFilterAndCountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsFilterAndCount(requestParameters: RecordsApiApiV1RecordsFilterAndCountRequest = {}, options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsFilterAndCount(requestParameters.recordId, requestParameters.brokerId, requestParameters.cardId, requestParameters.userId, requestParameters.minTime, requestParameters.maxTime, requestParameters.values, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for records using specified filter. Returns list of lists with values (and their order) that was specified by filter options
     * @summary Filter And Get
     * @param {RecordsApiApiV1RecordsFilterAndGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsFilterAndGet(requestParameters: RecordsApiApiV1RecordsFilterAndGetRequest = {}, options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsFilterAndGet(requestParameters.recordId, requestParameters.brokerId, requestParameters.cardId, requestParameters.userId, requestParameters.minTime, requestParameters.maxTime, requestParameters.values, options).then((request) => request(this.axios, this.basePath));
    }
}


