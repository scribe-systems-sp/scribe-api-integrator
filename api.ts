/* tslint:disable */
/* eslint-disable */
/**
 * Integrator API
 * API for your scryba brokers
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BodyDeleteBrokerApiV1BrokersBrokerDelete
 */
export interface BodyDeleteBrokerApiV1BrokersBrokerDelete {
    /**
     * 
     * @type {number}
     * @memberof BodyDeleteBrokerApiV1BrokersBrokerDelete
     */
    broker_id: number;
}
/**
 * 
 * @export
 * @interface BodyDeleteCardApiV1CardsCardDelete
 */
export interface BodyDeleteCardApiV1CardsCardDelete {
    /**
     * 
     * @type {number}
     * @memberof BodyDeleteCardApiV1CardsCardDelete
     */
    card_id: number;
}
/**
 * 
 * @export
 * @interface BodyDeleteTimeRecordApiV1RecordsRecordDelete
 */
export interface BodyDeleteTimeRecordApiV1RecordsRecordDelete {
    /**
     * 
     * @type {number}
     * @memberof BodyDeleteTimeRecordApiV1RecordsRecordDelete
     */
    recordId: number;
}
/**
 * 
 * @export
 * @interface BodySetActiveApiV1CardsSetActivePatch
 */
export interface BodySetActiveApiV1CardsSetActivePatch {
    /**
     * 
     * @type {boolean}
     * @memberof BodySetActiveApiV1CardsSetActivePatch
     */
    active: boolean;
    /**
     * 
     * @type {number}
     * @memberof BodySetActiveApiV1CardsSetActivePatch
     */
    card_id: number;
}
/**
 * 
 * @export
 * @interface BodySetBrokerConfigApiV1ConfigBrokerPut
 */
export interface BodySetBrokerConfigApiV1ConfigBrokerPut {
    /**
     * 
     * @type {string}
     * @memberof BodySetBrokerConfigApiV1ConfigBrokerPut
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof BodySetBrokerConfigApiV1ConfigBrokerPut
     */
    data_format?: string;
    /**
     * 
     * @type {string}
     * @memberof BodySetBrokerConfigApiV1ConfigBrokerPut
     */
    broker_name: string;
}
/**
 * 
 * @export
 * @interface Broker
 */
export interface Broker {
    /**
     * 
     * @type {string}
     * @memberof Broker
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Broker
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Brokers
 */
export interface Brokers {
    /**
     * 
     * @type {Array<Array<any>>}
     * @memberof Brokers
     */
    brokers: Array<Array<any>>;
}
/**
 * 
 * @export
 * @interface CardsData
 */
export interface CardsData {
    /**
     * 
     * @type {Array<Array<any>>}
     * @memberof CardsData
     */
    cards: Array<Array<any>>;
}
/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    timestamp: string;
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    data_format?: string;
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    data: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface NewCard
 */
export interface NewCard {
    /**
     * 
     * @type {number}
     * @memberof NewCard
     */
    userId: number;
    /**
     * 
     * @type {string}
     * @memberof NewCard
     */
    secret: string;
}
/**
 * 
 * @export
 * @interface RecordsCount
 */
export interface RecordsCount {
    /**
     * 
     * @type {number}
     * @memberof RecordsCount
     */
    count: number;
}
/**
 * 
 * @export
 * @interface TimeRecordFromBroker
 */
export interface TimeRecordFromBroker {
    /**
     * 
     * @type {string}
     * @memberof TimeRecordFromBroker
     */
    broker_name?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeRecordFromBroker
     */
    cardSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeRecordFromBroker
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeRecordFromBroker
     */
    note?: string;
    /**
     * 
     * @type {number}
     * @memberof TimeRecordFromBroker
     */
    user_id?: number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * BrokersApi - axios parameter creator
 * @export
 */
export const BrokersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new broker with specified parametres.
         * @summary Create Broker
         * @param {Broker} broker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersCreateBroker: async (broker: Broker, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'broker' is not null or undefined
            if (broker === null || broker === undefined) {
                throw new RequiredError('broker','Required parameter broker was null or undefined when calling apiV1BrokersCreateBroker.');
            }
            const localVarPath = `/integrator/api/v1/brokers/broker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof broker !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(broker !== undefined ? broker : {}) : (broker || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes broker. Note, that if the broker will be deleted, all the dependent timerecords for this broker will be also deleted cascadely.
         * @summary Delete Broker
         * @param {BodyDeleteBrokerApiV1BrokersBrokerDelete} bodyDeleteBrokerApiV1BrokersBrokerDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersDeleteBroker: async (bodyDeleteBrokerApiV1BrokersBrokerDelete: BodyDeleteBrokerApiV1BrokersBrokerDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeleteBrokerApiV1BrokersBrokerDelete' is not null or undefined
            if (bodyDeleteBrokerApiV1BrokersBrokerDelete === null || bodyDeleteBrokerApiV1BrokersBrokerDelete === undefined) {
                throw new RequiredError('bodyDeleteBrokerApiV1BrokersBrokerDelete','Required parameter bodyDeleteBrokerApiV1BrokersBrokerDelete was null or undefined when calling apiV1BrokersDeleteBroker.');
            }
            const localVarPath = `/integrator/api/v1/brokers/broker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeleteBrokerApiV1BrokersBrokerDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeleteBrokerApiV1BrokersBrokerDelete !== undefined ? bodyDeleteBrokerApiV1BrokersBrokerDelete : {}) : (bodyDeleteBrokerApiV1BrokersBrokerDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all brokers using provided filter parametres
         * @summary Get All Brokers
         * @param {number} [brokerId] Get only broker with specified id.
         * @param {string} [name] Return broker only with specified name.
         * @param {string} [nameSubstring] Return broker which has specified substring in his name.
         * @param {Array<string>} [values] Returns only specified parametres.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersGetAllBrokers: async (brokerId?: number, name?: string, nameSubstring?: string, values?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/brokers/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (brokerId !== undefined) {
                localVarQueryParameter['broker_id'] = brokerId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameSubstring !== undefined) {
                localVarQueryParameter['name_substring'] = nameSubstring;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrokersApi - functional programming interface
 * @export
 */
export const BrokersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new broker with specified parametres.
         * @summary Create Broker
         * @param {Broker} broker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BrokersCreateBroker(broker: Broker, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await BrokersApiAxiosParamCreator(configuration).apiV1BrokersCreateBroker(broker, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes broker. Note, that if the broker will be deleted, all the dependent timerecords for this broker will be also deleted cascadely.
         * @summary Delete Broker
         * @param {BodyDeleteBrokerApiV1BrokersBrokerDelete} bodyDeleteBrokerApiV1BrokersBrokerDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete: BodyDeleteBrokerApiV1BrokersBrokerDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await BrokersApiAxiosParamCreator(configuration).apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all brokers using provided filter parametres
         * @summary Get All Brokers
         * @param {number} [brokerId] Get only broker with specified id.
         * @param {string} [name] Return broker only with specified name.
         * @param {string} [nameSubstring] Return broker which has specified substring in his name.
         * @param {Array<string>} [values] Returns only specified parametres.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BrokersGetAllBrokers(brokerId?: number, name?: string, nameSubstring?: string, values?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brokers>> {
            const localVarAxiosArgs = await BrokersApiAxiosParamCreator(configuration).apiV1BrokersGetAllBrokers(brokerId, name, nameSubstring, values, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BrokersApi - factory interface
 * @export
 */
export const BrokersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates new broker with specified parametres.
         * @summary Create Broker
         * @param {Broker} broker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersCreateBroker(broker: Broker, options?: any): AxiosPromise<any> {
            return BrokersApiFp(configuration).apiV1BrokersCreateBroker(broker, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes broker. Note, that if the broker will be deleted, all the dependent timerecords for this broker will be also deleted cascadely.
         * @summary Delete Broker
         * @param {BodyDeleteBrokerApiV1BrokersBrokerDelete} bodyDeleteBrokerApiV1BrokersBrokerDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete: BodyDeleteBrokerApiV1BrokersBrokerDelete, options?: any): AxiosPromise<any> {
            return BrokersApiFp(configuration).apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all brokers using provided filter parametres
         * @summary Get All Brokers
         * @param {number} [brokerId] Get only broker with specified id.
         * @param {string} [name] Return broker only with specified name.
         * @param {string} [nameSubstring] Return broker which has specified substring in his name.
         * @param {Array<string>} [values] Returns only specified parametres.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BrokersGetAllBrokers(brokerId?: number, name?: string, nameSubstring?: string, values?: Array<string>, options?: any): AxiosPromise<Brokers> {
            return BrokersApiFp(configuration).apiV1BrokersGetAllBrokers(brokerId, name, nameSubstring, values, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrokersApi - object-oriented interface
 * @export
 * @class BrokersApi
 * @extends {BaseAPI}
 */
export class BrokersApi extends BaseAPI {
    /**
     * Creates new broker with specified parametres.
     * @summary Create Broker
     * @param {Broker} broker 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public apiV1BrokersCreateBroker(broker: Broker, options?: any) {
        return BrokersApiFp(this.configuration).apiV1BrokersCreateBroker(broker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes broker. Note, that if the broker will be deleted, all the dependent timerecords for this broker will be also deleted cascadely.
     * @summary Delete Broker
     * @param {BodyDeleteBrokerApiV1BrokersBrokerDelete} bodyDeleteBrokerApiV1BrokersBrokerDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete: BodyDeleteBrokerApiV1BrokersBrokerDelete, options?: any) {
        return BrokersApiFp(this.configuration).apiV1BrokersDeleteBroker(bodyDeleteBrokerApiV1BrokersBrokerDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all brokers using provided filter parametres
     * @summary Get All Brokers
     * @param {number} [brokerId] Get only broker with specified id.
     * @param {string} [name] Return broker only with specified name.
     * @param {string} [nameSubstring] Return broker which has specified substring in his name.
     * @param {Array<string>} [values] Returns only specified parametres.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public apiV1BrokersGetAllBrokers(brokerId?: number, name?: string, nameSubstring?: string, values?: Array<string>, options?: any) {
        return BrokersApiFp(this.configuration).apiV1BrokersGetAllBrokers(brokerId, name, nameSubstring, values, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CardsApi - axios parameter creator
 * @export
 */
export const CardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new card
         * @summary Create Card
         * @param {NewCard} newCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsCreateCard: async (newCard: NewCard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCard' is not null or undefined
            if (newCard === null || newCard === undefined) {
                throw new RequiredError('newCard','Required parameter newCard was null or undefined when calling apiV1CardsCreateCard.');
            }
            const localVarPath = `/integrator/api/v1/cards/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof newCard !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(newCard !== undefined ? newCard : {}) : (newCard || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deleets card. Note, that if the card will be deleted, all the dependent timerecords for this card will be also deleted cascadely.
         * @summary Delete Card
         * @param {BodyDeleteCardApiV1CardsCardDelete} bodyDeleteCardApiV1CardsCardDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsDeleteCard: async (bodyDeleteCardApiV1CardsCardDelete: BodyDeleteCardApiV1CardsCardDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeleteCardApiV1CardsCardDelete' is not null or undefined
            if (bodyDeleteCardApiV1CardsCardDelete === null || bodyDeleteCardApiV1CardsCardDelete === undefined) {
                throw new RequiredError('bodyDeleteCardApiV1CardsCardDelete','Required parameter bodyDeleteCardApiV1CardsCardDelete was null or undefined when calling apiV1CardsDeleteCard.');
            }
            const localVarPath = `/integrator/api/v1/cards/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeleteCardApiV1CardsCardDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeleteCardApiV1CardsCardDelete !== undefined ? bodyDeleteCardApiV1CardsCardDelete : {}) : (bodyDeleteCardApiV1CardsCardDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for and returns card using specified filter parametres.
         * @summary Filter And Get
         * @param {number} [id] Get only card with specified id.
         * @param {number} [userId] Return cards only for specified userIds.
         * @param {boolean} [active] Return cards which has provided status.
         * @param {string} [secret] Return card with specified secret.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsFilterAndGet: async (id?: number, userId?: number, active?: boolean, secret?: string, values?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/cards/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or deactivates card. Deactivated cards are not permitted to do any actions.
         * @summary Set Active
         * @param {BodySetActiveApiV1CardsSetActivePatch} bodySetActiveApiV1CardsSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsSetActive: async (bodySetActiveApiV1CardsSetActivePatch: BodySetActiveApiV1CardsSetActivePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodySetActiveApiV1CardsSetActivePatch' is not null or undefined
            if (bodySetActiveApiV1CardsSetActivePatch === null || bodySetActiveApiV1CardsSetActivePatch === undefined) {
                throw new RequiredError('bodySetActiveApiV1CardsSetActivePatch','Required parameter bodySetActiveApiV1CardsSetActivePatch was null or undefined when calling apiV1CardsSetActive.');
            }
            const localVarPath = `/integrator/api/v1/cards/setActive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodySetActiveApiV1CardsSetActivePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodySetActiveApiV1CardsSetActivePatch !== undefined ? bodySetActiveApiV1CardsSetActivePatch : {}) : (bodySetActiveApiV1CardsSetActivePatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardsApi - functional programming interface
 * @export
 */
export const CardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new card
         * @summary Create Card
         * @param {NewCard} newCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CardsCreateCard(newCard: NewCard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await CardsApiAxiosParamCreator(configuration).apiV1CardsCreateCard(newCard, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deleets card. Note, that if the card will be deleted, all the dependent timerecords for this card will be also deleted cascadely.
         * @summary Delete Card
         * @param {BodyDeleteCardApiV1CardsCardDelete} bodyDeleteCardApiV1CardsCardDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete: BodyDeleteCardApiV1CardsCardDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await CardsApiAxiosParamCreator(configuration).apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Searches for and returns card using specified filter parametres.
         * @summary Filter And Get
         * @param {number} [id] Get only card with specified id.
         * @param {number} [userId] Return cards only for specified userIds.
         * @param {boolean} [active] Return cards which has provided status.
         * @param {string} [secret] Return card with specified secret.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CardsFilterAndGet(id?: number, userId?: number, active?: boolean, secret?: string, values?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardsData>> {
            const localVarAxiosArgs = await CardsApiAxiosParamCreator(configuration).apiV1CardsFilterAndGet(id, userId, active, secret, values, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Activates or deactivates card. Deactivated cards are not permitted to do any actions.
         * @summary Set Active
         * @param {BodySetActiveApiV1CardsSetActivePatch} bodySetActiveApiV1CardsSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch: BodySetActiveApiV1CardsSetActivePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await CardsApiAxiosParamCreator(configuration).apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CardsApi - factory interface
 * @export
 */
export const CardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates new card
         * @summary Create Card
         * @param {NewCard} newCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsCreateCard(newCard: NewCard, options?: any): AxiosPromise<any> {
            return CardsApiFp(configuration).apiV1CardsCreateCard(newCard, options).then((request) => request(axios, basePath));
        },
        /**
         * Deleets card. Note, that if the card will be deleted, all the dependent timerecords for this card will be also deleted cascadely.
         * @summary Delete Card
         * @param {BodyDeleteCardApiV1CardsCardDelete} bodyDeleteCardApiV1CardsCardDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete: BodyDeleteCardApiV1CardsCardDelete, options?: any): AxiosPromise<any> {
            return CardsApiFp(configuration).apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for and returns card using specified filter parametres.
         * @summary Filter And Get
         * @param {number} [id] Get only card with specified id.
         * @param {number} [userId] Return cards only for specified userIds.
         * @param {boolean} [active] Return cards which has provided status.
         * @param {string} [secret] Return card with specified secret.
         * @param {Array<string>} [values] Only return specified fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsFilterAndGet(id?: number, userId?: number, active?: boolean, secret?: string, values?: Array<string>, options?: any): AxiosPromise<CardsData> {
            return CardsApiFp(configuration).apiV1CardsFilterAndGet(id, userId, active, secret, values, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates or deactivates card. Deactivated cards are not permitted to do any actions.
         * @summary Set Active
         * @param {BodySetActiveApiV1CardsSetActivePatch} bodySetActiveApiV1CardsSetActivePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch: BodySetActiveApiV1CardsSetActivePatch, options?: any): AxiosPromise<any> {
            return CardsApiFp(configuration).apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardsApi - object-oriented interface
 * @export
 * @class CardsApi
 * @extends {BaseAPI}
 */
export class CardsApi extends BaseAPI {
    /**
     * Creates new card
     * @summary Create Card
     * @param {NewCard} newCard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public apiV1CardsCreateCard(newCard: NewCard, options?: any) {
        return CardsApiFp(this.configuration).apiV1CardsCreateCard(newCard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deleets card. Note, that if the card will be deleted, all the dependent timerecords for this card will be also deleted cascadely.
     * @summary Delete Card
     * @param {BodyDeleteCardApiV1CardsCardDelete} bodyDeleteCardApiV1CardsCardDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete: BodyDeleteCardApiV1CardsCardDelete, options?: any) {
        return CardsApiFp(this.configuration).apiV1CardsDeleteCard(bodyDeleteCardApiV1CardsCardDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for and returns card using specified filter parametres.
     * @summary Filter And Get
     * @param {number} [id] Get only card with specified id.
     * @param {number} [userId] Return cards only for specified userIds.
     * @param {boolean} [active] Return cards which has provided status.
     * @param {string} [secret] Return card with specified secret.
     * @param {Array<string>} [values] Only return specified fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public apiV1CardsFilterAndGet(id?: number, userId?: number, active?: boolean, secret?: string, values?: Array<string>, options?: any) {
        return CardsApiFp(this.configuration).apiV1CardsFilterAndGet(id, userId, active, secret, values, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates or deactivates card. Deactivated cards are not permitted to do any actions.
     * @summary Set Active
     * @param {BodySetActiveApiV1CardsSetActivePatch} bodySetActiveApiV1CardsSetActivePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch: BodySetActiveApiV1CardsSetActivePatch, options?: any) {
        return CardsApiFp(this.configuration).apiV1CardsSetActive(bodySetActiveApiV1CardsSetActivePatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns configuration of the broker. If provided timestamp is same returns only 304 status code.
         * @summary Get Broker Config
         * @param {string} timestamp 
         * @param {string} brokerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConfigGetBrokerConfig: async (timestamp: string, brokerName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling apiV1ConfigGetBrokerConfig.');
            }
            // verify required parameter 'brokerName' is not null or undefined
            if (brokerName === null || brokerName === undefined) {
                throw new RequiredError('brokerName','Required parameter brokerName was null or undefined when calling apiV1ConfigGetBrokerConfig.');
            }
            const localVarPath = `/integrator/api/v1/config/broker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = (timestamp as any instanceof Date) ?
                    (timestamp as any).toISOString() :
                    timestamp;
            }

            if (brokerName !== undefined) {
                localVarQueryParameter['broker_name'] = brokerName;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates configuration for specific broker.
         * @summary Set Broker Config
         * @param {BodySetBrokerConfigApiV1ConfigBrokerPut} bodySetBrokerConfigApiV1ConfigBrokerPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConfigSetBrokerConfig: async (bodySetBrokerConfigApiV1ConfigBrokerPut: BodySetBrokerConfigApiV1ConfigBrokerPut, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodySetBrokerConfigApiV1ConfigBrokerPut' is not null or undefined
            if (bodySetBrokerConfigApiV1ConfigBrokerPut === null || bodySetBrokerConfigApiV1ConfigBrokerPut === undefined) {
                throw new RequiredError('bodySetBrokerConfigApiV1ConfigBrokerPut','Required parameter bodySetBrokerConfigApiV1ConfigBrokerPut was null or undefined when calling apiV1ConfigSetBrokerConfig.');
            }
            const localVarPath = `/integrator/api/v1/config/broker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodySetBrokerConfigApiV1ConfigBrokerPut !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodySetBrokerConfigApiV1ConfigBrokerPut !== undefined ? bodySetBrokerConfigApiV1ConfigBrokerPut : {}) : (bodySetBrokerConfigApiV1ConfigBrokerPut || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns configuration of the broker. If provided timestamp is same returns only 304 status code.
         * @summary Get Broker Config
         * @param {string} timestamp 
         * @param {string} brokerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConfigGetBrokerConfig(timestamp: string, brokerName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
            const localVarAxiosArgs = await ConfigApiAxiosParamCreator(configuration).apiV1ConfigGetBrokerConfig(timestamp, brokerName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates configuration for specific broker.
         * @summary Set Broker Config
         * @param {BodySetBrokerConfigApiV1ConfigBrokerPut} bodySetBrokerConfigApiV1ConfigBrokerPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut: BodySetBrokerConfigApiV1ConfigBrokerPut, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ConfigApiAxiosParamCreator(configuration).apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns configuration of the broker. If provided timestamp is same returns only 304 status code.
         * @summary Get Broker Config
         * @param {string} timestamp 
         * @param {string} brokerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConfigGetBrokerConfig(timestamp: string, brokerName: string, options?: any): AxiosPromise<Config> {
            return ConfigApiFp(configuration).apiV1ConfigGetBrokerConfig(timestamp, brokerName, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates configuration for specific broker.
         * @summary Set Broker Config
         * @param {BodySetBrokerConfigApiV1ConfigBrokerPut} bodySetBrokerConfigApiV1ConfigBrokerPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut: BodySetBrokerConfigApiV1ConfigBrokerPut, options?: any): AxiosPromise<any> {
            return ConfigApiFp(configuration).apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * Returns configuration of the broker. If provided timestamp is same returns only 304 status code.
     * @summary Get Broker Config
     * @param {string} timestamp 
     * @param {string} brokerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public apiV1ConfigGetBrokerConfig(timestamp: string, brokerName: string, options?: any) {
        return ConfigApiFp(this.configuration).apiV1ConfigGetBrokerConfig(timestamp, brokerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates configuration for specific broker.
     * @summary Set Broker Config
     * @param {BodySetBrokerConfigApiV1ConfigBrokerPut} bodySetBrokerConfigApiV1ConfigBrokerPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut: BodySetBrokerConfigApiV1ConfigBrokerPut, options?: any) {
        return ConfigApiFp(this.configuration).apiV1ConfigSetBrokerConfig(bodySetBrokerConfigApiV1ConfigBrokerPut, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecordsApi - axios parameter creator
 * @export
 */
export const RecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Groups records by userId and counts them
         * @summary Count By User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsCountByUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/records/countByUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates time record. Uses card secret to identify card. If card is not active, operation will fail.
         * @summary Create Time Record
         * @param {TimeRecordFromBroker} timeRecordFromBroker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsCreateTimeRecord: async (timeRecordFromBroker: TimeRecordFromBroker, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeRecordFromBroker' is not null or undefined
            if (timeRecordFromBroker === null || timeRecordFromBroker === undefined) {
                throw new RequiredError('timeRecordFromBroker','Required parameter timeRecordFromBroker was null or undefined when calling apiV1RecordsCreateTimeRecord.');
            }
            const localVarPath = `/integrator/api/v1/records/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof timeRecordFromBroker !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(timeRecordFromBroker !== undefined ? timeRecordFromBroker : {}) : (timeRecordFromBroker || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes time record.
         * @summary Delete Time Record
         * @param {BodyDeleteTimeRecordApiV1RecordsRecordDelete} bodyDeleteTimeRecordApiV1RecordsRecordDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsDeleteTimeRecord: async (bodyDeleteTimeRecordApiV1RecordsRecordDelete: BodyDeleteTimeRecordApiV1RecordsRecordDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyDeleteTimeRecordApiV1RecordsRecordDelete' is not null or undefined
            if (bodyDeleteTimeRecordApiV1RecordsRecordDelete === null || bodyDeleteTimeRecordApiV1RecordsRecordDelete === undefined) {
                throw new RequiredError('bodyDeleteTimeRecordApiV1RecordsRecordDelete','Required parameter bodyDeleteTimeRecordApiV1RecordsRecordDelete was null or undefined when calling apiV1RecordsDeleteTimeRecord.');
            }
            const localVarPath = `/integrator/api/v1/records/record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bodyDeleteTimeRecordApiV1RecordsRecordDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bodyDeleteTimeRecordApiV1RecordsRecordDelete !== undefined ? bodyDeleteTimeRecordApiV1RecordsRecordDelete : {}) : (bodyDeleteTimeRecordApiV1RecordsRecordDelete || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Counts recourds using specified filter. Returns records count instead of their values.
         * @summary Filter And Count
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {number} [offset] How many record to skip
         * @param {number} [limit] Limit max records count to specified value
         * @param {Array<string>} [orderBy] Order by specific field. For example [\&quot;broker__id\&quot;, \&quot;-time\&quot;]. Allowed values are same as in \&quot;values\&quot; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsFilterAndCount: async (recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, offset?: number, limit?: number, orderBy?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/records/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (recordId !== undefined) {
                localVarQueryParameter['recordId'] = recordId;
            }

            if (brokerId !== undefined) {
                localVarQueryParameter['brokerId'] = brokerId;
            }

            if (cardId !== undefined) {
                localVarQueryParameter['cardId'] = cardId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (minTime !== undefined) {
                localVarQueryParameter['minTime'] = (minTime as any instanceof Date) ?
                    (minTime as any).toISOString() :
                    minTime;
            }

            if (maxTime !== undefined) {
                localVarQueryParameter['maxTime'] = (maxTime as any instanceof Date) ?
                    (maxTime as any).toISOString() :
                    maxTime;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for records using specified filter. Returns list of lists with values (and their order) that was specified by filter options
         * @summary Filter And Get
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {number} [offset] How many record to skip
         * @param {number} [limit] Limit max records count to specified value
         * @param {Array<string>} [orderBy] Order by specific field. For example [\&quot;broker__id\&quot;, \&quot;-time\&quot;]. Allowed values are same as in \&quot;values\&quot; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsFilterAndGet: async (recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, offset?: number, limit?: number, orderBy?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrator/api/v1/records/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("OAuth2PasswordBearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (recordId !== undefined) {
                localVarQueryParameter['recordId'] = recordId;
            }

            if (brokerId !== undefined) {
                localVarQueryParameter['brokerId'] = brokerId;
            }

            if (cardId !== undefined) {
                localVarQueryParameter['cardId'] = cardId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (minTime !== undefined) {
                localVarQueryParameter['minTime'] = (minTime as any instanceof Date) ?
                    (minTime as any).toISOString() :
                    minTime;
            }

            if (maxTime !== undefined) {
                localVarQueryParameter['maxTime'] = (maxTime as any instanceof Date) ?
                    (maxTime as any).toISOString() :
                    maxTime;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordsApi - functional programming interface
 * @export
 */
export const RecordsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Groups records by userId and counts them
         * @summary Count By User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsCountByUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsCountByUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates time record. Uses card secret to identify card. If card is not active, operation will fail.
         * @summary Create Time Record
         * @param {TimeRecordFromBroker} timeRecordFromBroker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsCreateTimeRecord(timeRecordFromBroker: TimeRecordFromBroker, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsCreateTimeRecord(timeRecordFromBroker, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes time record.
         * @summary Delete Time Record
         * @param {BodyDeleteTimeRecordApiV1RecordsRecordDelete} bodyDeleteTimeRecordApiV1RecordsRecordDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete: BodyDeleteTimeRecordApiV1RecordsRecordDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Counts recourds using specified filter. Returns records count instead of their values.
         * @summary Filter And Count
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {number} [offset] How many record to skip
         * @param {number} [limit] Limit max records count to specified value
         * @param {Array<string>} [orderBy] Order by specific field. For example [\&quot;broker__id\&quot;, \&quot;-time\&quot;]. Allowed values are same as in \&quot;values\&quot; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsFilterAndCount(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, offset?: number, limit?: number, orderBy?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordsCount>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsFilterAndCount(recordId, brokerId, cardId, userId, minTime, maxTime, values, offset, limit, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Searches for records using specified filter. Returns list of lists with values (and their order) that was specified by filter options
         * @summary Filter And Get
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {number} [offset] How many record to skip
         * @param {number} [limit] Limit max records count to specified value
         * @param {Array<string>} [orderBy] Order by specific field. For example [\&quot;broker__id\&quot;, \&quot;-time\&quot;]. Allowed values are same as in \&quot;values\&quot; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1RecordsFilterAndGet(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, offset?: number, limit?: number, orderBy?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await RecordsApiAxiosParamCreator(configuration).apiV1RecordsFilterAndGet(recordId, brokerId, cardId, userId, minTime, maxTime, values, offset, limit, orderBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RecordsApi - factory interface
 * @export
 */
export const RecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Groups records by userId and counts them
         * @summary Count By User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsCountByUser(options?: any): AxiosPromise<any> {
            return RecordsApiFp(configuration).apiV1RecordsCountByUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates time record. Uses card secret to identify card. If card is not active, operation will fail.
         * @summary Create Time Record
         * @param {TimeRecordFromBroker} timeRecordFromBroker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsCreateTimeRecord(timeRecordFromBroker: TimeRecordFromBroker, options?: any): AxiosPromise<any> {
            return RecordsApiFp(configuration).apiV1RecordsCreateTimeRecord(timeRecordFromBroker, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes time record.
         * @summary Delete Time Record
         * @param {BodyDeleteTimeRecordApiV1RecordsRecordDelete} bodyDeleteTimeRecordApiV1RecordsRecordDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete: BodyDeleteTimeRecordApiV1RecordsRecordDelete, options?: any): AxiosPromise<any> {
            return RecordsApiFp(configuration).apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Counts recourds using specified filter. Returns records count instead of their values.
         * @summary Filter And Count
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {number} [offset] How many record to skip
         * @param {number} [limit] Limit max records count to specified value
         * @param {Array<string>} [orderBy] Order by specific field. For example [\&quot;broker__id\&quot;, \&quot;-time\&quot;]. Allowed values are same as in \&quot;values\&quot; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsFilterAndCount(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, offset?: number, limit?: number, orderBy?: Array<string>, options?: any): AxiosPromise<RecordsCount> {
            return RecordsApiFp(configuration).apiV1RecordsFilterAndCount(recordId, brokerId, cardId, userId, minTime, maxTime, values, offset, limit, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for records using specified filter. Returns list of lists with values (and their order) that was specified by filter options
         * @summary Filter And Get
         * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
         * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
         * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
         * @param {number} [userId] Match specific user. Response will contain only records for specified user.
         * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
         * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
         * @param {Array<string>} [values] Response records will contain only specified data.
         * @param {number} [offset] How many record to skip
         * @param {number} [limit] Limit max records count to specified value
         * @param {Array<string>} [orderBy] Order by specific field. For example [\&quot;broker__id\&quot;, \&quot;-time\&quot;]. Allowed values are same as in \&quot;values\&quot; field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1RecordsFilterAndGet(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, offset?: number, limit?: number, orderBy?: Array<string>, options?: any): AxiosPromise<any> {
            return RecordsApiFp(configuration).apiV1RecordsFilterAndGet(recordId, brokerId, cardId, userId, minTime, maxTime, values, offset, limit, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecordsApi - object-oriented interface
 * @export
 * @class RecordsApi
 * @extends {BaseAPI}
 */
export class RecordsApi extends BaseAPI {
    /**
     * Groups records by userId and counts them
     * @summary Count By User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsCountByUser(options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsCountByUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates time record. Uses card secret to identify card. If card is not active, operation will fail.
     * @summary Create Time Record
     * @param {TimeRecordFromBroker} timeRecordFromBroker 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsCreateTimeRecord(timeRecordFromBroker: TimeRecordFromBroker, options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsCreateTimeRecord(timeRecordFromBroker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes time record.
     * @summary Delete Time Record
     * @param {BodyDeleteTimeRecordApiV1RecordsRecordDelete} bodyDeleteTimeRecordApiV1RecordsRecordDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete: BodyDeleteTimeRecordApiV1RecordsRecordDelete, options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsDeleteTimeRecord(bodyDeleteTimeRecordApiV1RecordsRecordDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Counts recourds using specified filter. Returns records count instead of their values.
     * @summary Filter And Count
     * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
     * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
     * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
     * @param {number} [userId] Match specific user. Response will contain only records for specified user.
     * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
     * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
     * @param {Array<string>} [values] Response records will contain only specified data.
     * @param {number} [offset] How many record to skip
     * @param {number} [limit] Limit max records count to specified value
     * @param {Array<string>} [orderBy] Order by specific field. For example [\&quot;broker__id\&quot;, \&quot;-time\&quot;]. Allowed values are same as in \&quot;values\&quot; field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsFilterAndCount(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, offset?: number, limit?: number, orderBy?: Array<string>, options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsFilterAndCount(recordId, brokerId, cardId, userId, minTime, maxTime, values, offset, limit, orderBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for records using specified filter. Returns list of lists with values (and their order) that was specified by filter options
     * @summary Filter And Get
     * @param {number} [recordId] Match specific record id. If assigned, other filters doesnt make sens.
     * @param {number} [brokerId] Match specific broker id. Response will contain records only for specified broker.
     * @param {number} [cardId] Match specific card id. Response will contain records only for specified card.
     * @param {number} [userId] Match specific user. Response will contain only records for specified user.
     * @param {string} [minTime] Minimal timestamp to search for. Response will contain records that was added after specified time.
     * @param {string} [maxTime] Maximum timestamp to search for. Response will contain records that was added before specified time.
     * @param {Array<string>} [values] Response records will contain only specified data.
     * @param {number} [offset] How many record to skip
     * @param {number} [limit] Limit max records count to specified value
     * @param {Array<string>} [orderBy] Order by specific field. For example [\&quot;broker__id\&quot;, \&quot;-time\&quot;]. Allowed values are same as in \&quot;values\&quot; field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordsApi
     */
    public apiV1RecordsFilterAndGet(recordId?: number, brokerId?: number, cardId?: number, userId?: number, minTime?: string, maxTime?: string, values?: Array<string>, offset?: number, limit?: number, orderBy?: Array<string>, options?: any) {
        return RecordsApiFp(this.configuration).apiV1RecordsFilterAndGet(recordId, brokerId, cardId, userId, minTime, maxTime, values, offset, limit, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}


